rm(list=ls());
graphics.off();
require(RMySQL);
source("~/cake/libeix.r");

set.seed(0);

algo.arma <- function(tm, params, Y, E)
{
    p <- dim(prices)[2];
    ## £ exposed for every £ invested, i.e. price for each unit of the portfolio
    leverage <- apply(abs(E$vectors), MARGIN=2, FUN=sum);
    K <- 1;
    while(E$values[K] > 1.0e-6) K <- K + 1;
    K <- K - 1;
    ## mean, sd, GDA score, expected loss when we are in loss for each £ exposed.
    metrics <- matrix(NA, nrow=K, ncol=4);
    SR <- function(mu, sig) {
        I <- integrate(
            f=function(x) x * dnorm(x, mean=mu, sd=sig),
            lower=if (mu > 0) -Inf else 0,
            upper=if (mu > 0) 0 else Inf,
            rel.tol=1.0e-2
        );
        score <- mu + params$gda * I$value;
        if (mu > 0) {
            es <- abs(I$value)/pnorm(0, mean=mu, sd=sig);
        } else {
            es <- abs(I$value)/(1 - pnorm(0, mean=mu, sd=sig));
        }
        return(c(score, es));
    }
    for (i in 1:K) {
        model <- fit.arma(Y[, i], order.max=c(2,2));
        prediction <- predict(model, n.ahead=1);
        if (length(model$coef) > 0) {
            mu <- prediction$pred[1];
            sig <- prediction$se[1];
            metrics[i, 1:2] <- c(mu, sig);
            metrics[i, 3:4] <- SR(mu, sig);
        } else {
            ## No gain expected. We don't gamble.
            metrics[i, 1] <- 0;
            metrics[i, 2] <- prediction$se[1];
            metrics[i, 3:4] <- NA;
        }
    }
    if (sum(!is.na(metrics[, 3])) == 0) {
        return(rep(0, p));
    }
    i <- which.max(abs(metrics[, 3]));
    exposure <- params$loss.tol/metrics[i, 4];
    shares <- rep(0, p);
    if (abs(metrics[i, 3]) > params$score.min) {
        ## shares <- sign(metrics[i, 1]) * exposure/leverage[i] * E$vectors[, i]/prices[tm, ];
        shares <- sign(metrics[i, 1]) * exposure * E$vectors[, i]/prices[tm, ];
    }

    ## H <- matrix(NA, nrow=p, ncol=p);    
    ## ## scores <- abs(sharpe) * scheme.score;
    ## normalizer <- sum(abs(scores));
    ## ## £ to invest in eigen portfolio i
    ## to.expose <- abs(scores) / normalizer;
    ## for (i in 1:p) {
    ##     H[i, ] <- sign(scores[i]) * (to.expose[i]/leverage[i]) * E$vectors[, i] / prices[tm, ];
    ## }
    ## shares <- apply(H, MARGIN=2, FUN=sum);
    ## k <- sum(abs(shares) * prices[tm, ]);
    ## shares <- shares/k;
    return(shares);
}

factor.algo.2 <- function(tm, params, holding)
{
    p <- dim(prices)[2];
    invested <- holding[1:p] * prices[tm, 1:p];
    wealth <- sum(invested) + holding[p+1];
    stopifnot(wealth > 0);
    ret <- apply(prices[(tm-params$T1+1):tm, 1:p],
                 MARGIN=2, FUN=function(x) tail(x, n=-1)/head(x, n=-1) - 1);
    C <- cov(ret);
    E <- eigen(C);
    Y <- ret %*% E$vectors;

    ## H <- matrix(NA, nrow=2, ncol=p);

    ## s <- params$alloc + 1;
    ## H[1, ] <- 0;
    ## H[2, ] <- algo.arma(tm, params, Y, E, 1/s);
    ## shares <- apply(H, MARGIN=2, FUN=sum);
    shares <- algo.arma(tm, params, Y, E);
    ## shares <- shares * wealth * params$exposure;
    shares <- shares * wealth;
    
    holding[p+1] <- holding[p+1] - sum((shares - holding[1:p]) * prices[tm, ]);
    holding[1:p] <- shares;
    return(holding);
}

gen.strat <- function(holding)
{
    T1 <- runif(1, min=15, max=60);
    loss.tol <- runif(1, min=1.0e-3, max=5.0e-3);
    gda <- runif(1, min=0.05, max=1);
    score.min <- runif(1, min=1.0e-3, max=1.0e-2);
    params <- list(T1=round(T1),
                   gda=gda,
                   score.min=score.min,
                   loss.tol=loss.tol
                   );
    return(list(fun=factor.algo.2, params=params, holding=holding));
}

save.conf <- function(strats, R)
{
    T1 <- sapply(1:length(strats), FUN=function(i) strats[[i]]$params$T1);
    GDA <- sapply(1:length(strats), FUN=function(i) strats[[i]]$params$gda);
    score.min <- sapply(1:length(strats), FUN=function(i) strats[[i]]$params$score.min);
    loss.tol <- sapply(1:length(strats), FUN=function(i) strats[[i]]$params$loss.tol);
    save(T1, GDA, score.min, loss.tol, R, file="StratsReturns.RData");
}

symbols <- c(
    "spy",
    "aal",
    "aapl",
    "acn",
    "adbe",
    "adm",
    "aes",
    "amd",
    "amp",
    "amzn",
    "ba",
    "blk",
    "bsx",
    "bxp",
    "c",
    "cbg",
    "cbs",
    "celg",
    "clx",
    "cnp",
    "cog",
    "cvx",
    "d",
    "dbb",
    "dgx",
    "duk",
    "dvn",
    "ewg",
    "ewj",
    "ewl",
    "ewn",
    "ewp",
    "ewq",
    "ewu",
    "f",
    "fox",
    "fxb",
    "fxc",
    "fxe",
    "fxy",
    "gd",
    "goog",
    "iau",
    "ibm",
    "jjc",
    "jpm",
    "ko",
    "luv",
    "mmm",
    "nke",
    "nvda",
    "pep",
    "pg",
    "pru",
    "qcom",
    "rcl",
    "rht",
    "sbac",
    "see",
    "slv",
    "syk",
    "syy",
    "t",
    "tsn",
    "txn",
    "udr",
    "ung",
    "unp",
    "ups",
    "uso",
    "utx",
    "uup",
    "var",
    "vfc",
    "wat",
    "whr",
    "wm",
    "wmt",
    "xec",
    "xlp",
    "xrx",
    "yum"
);

database = dbConnect(MySQL(), user='sinbaski', password='q1w2e3r4',
                     dbname='market', host="192.168.154.1");

days <- matrix(NA, ncol=2, nrow=length(symbols));
for (i in 1:length(symbols)) {
    rs <- dbSendQuery(database, sprintf("select min(tm), max(tm) from %s_daily;", symbols[i]));
    days[i, ] <- as.matrix(fetch(rs, n=-1));
}
day1 <- max(days[, 1]);
day2 <- min(days[, 2]);
excluded <- {};
n <- NA;
for (i in 1:length(symbols)) {
    rs <- dbSendQuery(database,
                      sprintf(paste("select high, low, closing from %s_daily ",
                                    "where tm between '%s' and '%s'",
                                    "order by tm;"),
                              symbols[i], day1, day2));
    data <- fetch(rs, n=-1);
    if (i == 1) {
        prices <- data$closing;
        highs <- data$high;
        lows <- data$low;
        n <- dim(data)[1];
    } else {
        if (dim(data)[1] == n) {
            prices <- cbind(prices, data$closing);
            highs <- cbind(highs, data$high);
            lows <- cbind(lows, data$low);
        } else {
            excluded <- c(excluded, i);
        }
    }
    dbClearResult(rs);
}
dbDisconnect(database);

p <- dim(prices)[2];

log.mutation <- function(x, sig)
{
    stopifnot(min(x) > 0);
    exp(log(x) + rnorm(n=length(x), mean=0, sd=sig));
}

strats <- vector("list", length=500);
for (i in 1:length(strats)) {
    holding <- c(rep(0, p), 1);
    strats[[i]] <- gen.strat(holding);
}

sys.holding <- matrix(NA, nrow=dim(prices)[1], ncol=dim(prices)[2]+1);


V <- rep(NA, dim(prices)[1]);
V.max <- rep(1, dim(prices)[1]);
DD <- rep(NA, dim(prices)[1]);

require(foreach);
require(doMC);
require(sde);
registerDoMC(detectCores());
cl <- makeCluster(detectCores());

t0 <- 120;
t1 <- t0;
wealths <- matrix(1, ncol=2, nrow=length(strats));
## for (tm in 233:260) {
for (tm in 543:1000) {
    wealths[, 2] <- sapply(
        1:length(strats),
        FUN=function(i) {
            sum(strats[[i]]$holding[1:p] * prices[tm, ]) + strats[[i]]$holding[p+1];
        }
    );
    V[tm] <- mean(wealths[, 2]);
    V.max[tm] = if (V[tm] > V.max[tm-1]) V[tm] else V.max[tm-1];
    DD[tm] <- 1 - V[tm]/V.max[tm];
    holding <- t(sapply(1:length(strats), FUN=function(i) strats[[i]]$holding));
    sys.holding[tm, ] <- apply(holding, MARGIN=2, FUN=mean);
    
    cat(sprintf("At time %d, DD=%.3f, value = %.3f\n", tm, DD[tm], V[tm]));

    if (tm - t1 >= 5) {
        ret <- sapply((t1+1):tm, FUN=function(k) V[k]/V[k-1] - 1);
        F <- fit.dist(ret);
        if (F$bic < Inf) {
            prob <- F$fun.p(0);
        } else {
            prob <- max(sum(ret < -2.0e-3)/length(ret), 0.1);
        }
    } else {
        prob <- 0.1;
    }
    flag <- sample(x=c(TRUE, FALSE), size=1, replace=TRUE, prob=c(prob, 1- prob));
    if (!flag) {
        cat(sprintf("    prob=%.2f. continue\n", prob));
        holding <- foreach(i=1:length(strats), .combine=rbind) %dopar% {
            strats[[i]]$fun(tm, strats[[i]]$params, strats[[i]]$holding);
        }
        for (i in 1:length(strats)) {
            strats[[i]]$holding <- holding[i, ];
        }
        next;
    }

    ## Compute statistics since the last selection or regeneration
    cat(sprintf("    prob=%.2f. evaluate.\n", prob));
    R <- wealths[, 2]/wealths[, 1] - 1;
    mu <- mean(R);
    R.max <- max(R);
    save.conf(strats, R);
    
    cat("    Returns: ", c(min(R), mu, R.max), "\n");
    ## Bad performance. Search the entire configuration space
    idx <- which.max(R);
    cat("    Best:  ", paste(strats[[idx]]$params), "\n");
    idx <- which.min(R);
    cat("    Worst: ", paste(strats[[idx]]$params), "\n");
    cat(sprintf("    SPY:   %.3f\n", prices[tm, 1]/prices[t1, 1] - 1));
    
    if (tm - t1 >= 2) {
        T <- t.test(sapply((t1+1):tm, FUN=function(i) V[i]/V[i-1] - 1));
    } else {
        T <- list(p.value=NA, estimate=NA);
    }
    cat(sprintf("    t-test: p-value=%.3f, estimate=%.3f",
                T$p.value, T$estimate), "\n");
    if (max(R) < 0.01 || (!is.na(T$p.value) && T$p.value < 0.2 && T$estimate < 0)) {
        cat(sprintf("    regenerate.\n"));
        for (i in 1:length(strats)) {
            holding <- c(rep(0, p), mean(wealths[, 2]));
            strats[[i]] <- gen.strat(holding);
        }
        t1 <- tm;
        next;
    }

    ## who survive to the next period?
    cat(sprintf("    select.\n"));
    fitness <- 4^((R - mu)/0.01);
    winners <- rle(sample(1:length(strats), size=length(strats),
                          prob=fitness, replace=TRUE));
    k <- sum(wealths[, 2])/sum(wealths[winners$values, 2] * winners$length);
    holding <- foreach(i=winners$values, .combine=rbind) %dopar% {
        k * strats[[i]]$fun(tm, strats[[i]]$params, strats[[i]]$holding);
    }
    for (i in 1:length(winners$values)) {
        j <- winners$values[i];
        strats[[j]]$holding <- holding[i, ];
    }

    ## k <- sum(wealths[, 2])/sum(wealths[winners, 2]);
    ## Now let the winners adjust our positions
    ## foreach(i=winners$values) %dopar% {
    ##     strats[[i]]$holding <- k * strats[[i]]$fun(tm, strats[[i]]$params, strats[[i]]$holding);
    ## }
    strats <- rep(strats[winners$values], winners$length);
    wealths[, 1] <- rep(k*wealths[winners$values, 2], winners$length);
    cat(sprintf("    %d (%d) selected.\n", length(winners$values), length(strats)));
    ## strats <- strats[winners];
    ## for (i in 1:length(strats)) {
    ##     strats[[i]]$holding <- strats[[i]]$holding * k;
    ##     wealths[i, 1] <- wealths[winners[i], 2] * k;
    ## }
    ## sys.holding[tm, ] <- parApply(cl, holding[winners, ] * k, MARGIN=2, FUN=mean);

    ## Survivors mutate
    sig <- 0.05 * exp(1 - V[tm]/V[t1]);
    t1 <- tm;
    for (i in 1:length(strats)) {
        l <- round(log.mutation(strats[[i]]$params$T1, sig));
        l <- min(tm, max(l, 5));
        strats[[i]]$params$T1 <- l;
        strats[[i]]$params$loss.tol <- min(log.mutation(strats[[i]]$params$loss.tol, sig), 1);
        strats[[i]]$params$gda <- log.mutation(strats[[i]]$params$gda, sig);
        strats[[i]]$params$score.min <- log.mutation(strats[[i]]$params$score.min, sig);
    }
}
stopCluster(cl);

## W <- holding[, 1:p] %*% prices[tm, ] + holding[, p+1];
## DD <- 1 - V[t0:tm]/V.max[t0:tm];
## days <- data[, 1];

T1 <- sapply(1:length(strats), FUN=function(i) strats[[i]]$params$T1);
GDA <- sapply(1:length(strats), FUN=function(i) strats[[i]]$params$gda);
score.min <- sapply(1:length(strats), FUN=function(i) strats[[i]]$params$score.min);
loss.tol <- sapply(1:length(strats), FUN=function(i) strats[[i]]$params$loss.tol);
A <- cbind(T1, GDA, score.min, loss.tol);

## save(data, V, W, t0, t1, tm, days, holding,
##      T1, T2, alloc, exposure, confidence,
##      file="evolution.RData");

save(T1, GDA, score.min, loss.tol, R, file="StratsReturns.RData");

## load(file="evolution.RData");
for (i in 1:length(strats)) {
    strats[[i]]$holding <- c(rep(0, p), 1);
}
